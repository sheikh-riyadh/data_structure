#include <bits/stdc++.h>
using namespace std;
int main()
{

    /*
    আমাদের O(logN) complexity মুলত আমাদের যেই লুপ গুণিত আকারে আগাই অথবা ভাগ আকারে আগাই সেটাকে
    আমরা O(logN) complexity মধ্যে ফেলতে পারি যেমনঃ

    উদাহারন ১ঃ
    ==========
    আমরা দেখতে পাচ্ছি আমাদের লুপটি for(int i=0; i<n; i=i*2) i এর মান ২ গুল করে প্রতি স্টেপে বৃদ্ধি পাচ্ছে
    মানে আমরা আমাদের লুপটি গুণিত আকারে i এর মান বৃদ্ধি পাচ্ছে যখনি আমাদের লুপ গুণিত আকারে আগাতে থাকে
    সেটাকে আমরা O(logN) complexity ফেলতে পারি ।


    উদাহারন ২ঃ
    =========
    আমরা ২য় লুপটিতে দেখতে পাচ্ছি সেখানে N এর মান n/2 মানে ২ দারা প্রতিবার ভাগ করা হচ্ছে যেহেতু আমাদের n কে ভাগ করা
    হচ্ছে তাহলে আমরা ২য় লুপটিকে O(logN); ফেলতে পারি ।

    আমরা O(N) complexity মধ্যে ১সেকেন্ডে 10^7 = 10000000 পর্যন্ত অপারেশন করতে পারি মানে ১ কোটি আমাদের যদি বলা হয় আমাদের ১ সেকেন্ডের
    মধ্যে একটি প্রগ্রাম রান করতে হবে তাহলে অবশ্যয় আমাদের N এর মান ১ কোটির মধ্যে থাকতে হবে যদি বলে ২ সেকেন্ড তাহলে আমাদের 
    N এর মান হতে হবে 2x10^7 মানে ১০ কোটি মানে সেকেন্ড এর সাথে (second x 10^7) .




    কিন্তু আমাদের O(logN) complexity 10^18 = 1000000000000000000 value পর্যন্ত অপারেশন করতে পারি
    আমরা O(logN) complexity নিয়ে কাজ করলে অনেক বেশি value নিয়ে কাজ করতে পারি এর জন্য O(N) থেকে better .

    আমাদের লুপটি ১ সেকেন্ডে 10^7 মানে ১ কোটি চলতে পারে কিন্তু মজার বিষয় হল আমরা যদি O(logN) complexity তে 
    লুপ চালাই 9000000000000000000 এত্ত বড় একটা value নিয়ে কাজ করতে আমাদের লুপ মাত্র ৬3 বার চলবে যেখানে 
    আমাদের লুপটি ১ সেকেন্ডে 10^7 মানে ১ কোটি বার চলতে পারে সেখানে O(logN) complexity মাত্র ৬৩ বার চলে কাজ শেষ হয়ে যাবে


     */

    int n;
    cin >> n;

    // উদাহারন ১ঃ
    for (int i = 0; i < n; i = i * 2)
    {
        cout << i;
    }

    // উদাহারন ২ঃ
    while (n)
    {
        int digit = n % 10;
        cout << digit;
        n = n / 10;
    }

    return 0;
}